package com.intteq.storage.gcs;

import com.google.auth.oauth2.GoogleCredentials;
import com.google.cloud.storage.BlobInfo;
import com.google.cloud.storage.HttpMethod;
import com.google.cloud.storage.Storage;
import com.google.cloud.storage.StorageOptions;
import com.intteq.storage.core.ObjectStorageService;
import com.intteq.storage.core.PreSignedUpload;
import com.intteq.storage.core.exception.PreSignedUrlGenerationException;
import com.intteq.storage.core.exception.StorageDeleteException;
import com.intteq.storage.core.util.MimeTypeUtil;

import java.io.FileInputStream;
import java.net.URL;
import java.time.Duration;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

/**
 * Google Cloud Storage implementation of {@link ObjectStorageService}.
 *
 * <p>This service provides signed URL support for private GCS buckets using
 * <strong>V4 signatures</strong>. All file access URLs generated by this
 * implementation are <em>time-limited</em> and do not require public bucket
 * access.
 *
 * <h3>Supported operations</h3>
 * <ul>
 *   <li>Signed upload URLs (PUT)</li>
 *   <li>Signed read URLs (GET)</li>
 *   <li>Object deletion</li>
 * </ul>
 *
 * <h3>Expiry handling</h3>
 * <ul>
 *   <li>If an explicit expiry is provided, it is used as-is</li>
 *   <li>If {@code null}, zero, or negative, a safe default is applied</li>
 *   <li>The default expiry is enforced to avoid {@link NullPointerException}</li>
 * </ul>
 *
 * <p><strong>Note:</strong> Google Cloud Storage requires an explicit expiry
 * for signed URLs; permanent URLs are not supported.
 */
public class GcsStorageService implements ObjectStorageService {

    /**
     * Fallback expiry used when no valid expiry is provided.
     *
     * <p>This value is intentionally short-lived to avoid long-running
     * access to private objects.
     */
    private static final Duration FALLBACK_EXPIRY = Duration.ofHours(1);

    private final Storage storage;
    private final String bucket;
    private final Duration defaultReadExpiry;

    /**
     * Creates a new {@code GcsStorageService} using a service account
     * credentials file.
     *
     * @param bucket
     *         the target GCS bucket name (must exist)
     * @param credentialsPath
     *         absolute or relative path to the service account JSON file
     * @param defaultReadExpiry
     *         default expiry for signed read URLs; if {@code null}, zero,
     *         or negative, a fallback value is applied
     *
     * @throws RuntimeException
     *         if credentials cannot be loaded or the GCS client
     *         cannot be initialized
     */
    public GcsStorageService(
            String bucket,
            String credentialsPath,
            Duration defaultReadExpiry
    ) {

        if (bucket == null || bucket.isBlank()) {
            throw new IllegalArgumentException("GCS bucket must not be null or empty");
        }
        if (credentialsPath == null || credentialsPath.isBlank()) {
            throw new IllegalArgumentException("GCS credentialsPath must not be null or empty");
        }

        try (FileInputStream inputStream =
                     new FileInputStream(credentialsPath)) {

            GoogleCredentials credentials =
                    GoogleCredentials.fromStream(inputStream);

            this.storage =
                    StorageOptions.newBuilder()
                            .setCredentials(credentials)
                            .build()
                            .getService();

            this.bucket = bucket;
            this.defaultReadExpiry = normalizeExpiry(defaultReadExpiry);

        } catch (Exception ex) {
            throw new RuntimeException(
                    "Failed to load GCS credentials from: " + credentialsPath,
                    ex
            );
        }
    }

    /**
     * Generates a signed upload URL (HTTP PUT) for a new object.
     *
     * <p>The returned {@link PreSignedUpload} contains:
     * <ul>
     *   <li>A signed upload URL</li>
     *   <li>A generated unique filename</li>
     *   <li>A signed, viewable read URL</li>
     *   <li>Required HTTP headers</li>
     * </ul>
     *
     * @param directory
     *         logical directory/prefix inside the bucket
     * @param contentType
     *         MIME content type of the uploaded object
     * @param expiry
     *         expiry duration for the upload URL; if {@code null},
     *         a default value is applied
     *
     * @return a {@link PreSignedUpload} descriptor
     *
     * @throws PreSignedUrlGenerationException
     *         if URL generation fails
     */
    @Override
    public PreSignedUpload generateUploadUrl(
            String directory,
            String contentType,
            Duration expiry
    ) {
        Duration effectiveExpiry = normalizeExpiry(expiry);
        String dir = normalizeDirectory(directory);

        String fileName =
                UUID.randomUUID() + MimeTypeUtil.toExtension(contentType);

        String objectPath = dir.isEmpty()
                ? fileName
                : dir + "/" + fileName;

        try {
            BlobInfo blobInfo =
                    BlobInfo.newBuilder(bucket, objectPath)
                            .setContentType(contentType)
                            .build();

            URL uploadUrl =
                    storage.signUrl(
                            blobInfo,
                            effectiveExpiry.toSeconds(),
                            TimeUnit.SECONDS,
                            Storage.SignUrlOption.httpMethod(HttpMethod.PUT),
                            Storage.SignUrlOption.withV4Signature()
                    );

            String readUrl;
            try {
                readUrl = generateReadUrl(dir, fileName);
            } catch (Exception ex) {
                throw new PreSignedUrlGenerationException(
                        "Upload URL generated successfully, but failed to generate read URL for object: " + objectPath,
                        ex
                );
            }

            return PreSignedUpload.builder()
                    .uploadUrl(uploadUrl.toString())
                    .fileName(fileName)
                    .fileUrl(readUrl)
                    .headers(Map.of(
                            "Content-Type", contentType
                    ))
                    .build();

        } catch (PreSignedUrlGenerationException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new PreSignedUrlGenerationException(
                    "Failed to generate GCS upload URL for object: " + objectPath,
                    ex
            );
        }
    }

    /**
     * Generates a signed, read-only URL using the default expiry.
     *
     * @param directory
     *         logical directory/prefix
     * @param fileName
     *         object name
     *
     * @return signed read URL
     */
    public String generateReadUrl(String directory, String fileName) {
        return generateReadUrl(directory, fileName, defaultReadExpiry);
    }

    /**
     * Generates a signed, read-only URL with a custom expiry.
     *
     * @param directory
     *         logical directory/prefix
     * @param fileName
     *         object name
     * @param expiry
     *         expiry duration; if {@code null}, default expiry is applied
     *
     * @return signed read URL
     *
     * @throws PreSignedUrlGenerationException
     *         if URL generation fails
     */
    public String generateReadUrl(
            String directory,
            String fileName,
            Duration expiry
    ) {
        Duration effectiveExpiry = normalizeExpiry(expiry);

        String dir = normalizeDirectory(directory);
        String name = requireFileName(fileName);

        String objectPath = dir.isEmpty()
                ? name
                : dir + "/" + name;

        try {
            BlobInfo blobInfo =
                    BlobInfo.newBuilder(bucket, objectPath)
                            .build();

            return storage.signUrl(
                    blobInfo,
                    effectiveExpiry.toSeconds(),
                    TimeUnit.SECONDS,
                    Storage.SignUrlOption.httpMethod(HttpMethod.GET),
                    Storage.SignUrlOption.withV4Signature()
            ).toString();

        } catch (Exception ex) {
            throw new PreSignedUrlGenerationException(
                    "Failed to generate GCS read URL for object: " + objectPath,
                    ex
            );
        }
    }

    /**
     * Deletes an object from the bucket.
     *
     * @param directory
     *         logical directory/prefix
     * @param fileName
     *         object name
     *
     * @throws StorageDeleteException
     *         if deletion fails
     */
    @Override
    public void delete(String directory, String fileName) {
        String dir = normalizeDirectory(directory);
        String name = requireFileName(fileName);

        String objectPath = dir.isEmpty()
                ? name
                : dir + "/" + name;

        try {
            storage.delete(bucket, objectPath);
        } catch (Exception ex) {
            throw new StorageDeleteException(
                    "Failed to delete GCS object: " + objectPath,
                    ex
            );
        }
    }

    /**
     * Returns a signed, viewable URL for an object.
     *
     * <p>This method always returns a signed URL and never assumes
     * public bucket access.
     *
     * @param directory
     *         logical directory/prefix
     * @param fileName
     *         object name
     * @param expiry
     *         optional expiry duration; if {@code null}, default expiry is used
     *
     * @return signed read URL
     */
    @Override
    public String getFileUrl(
            String directory,
            String fileName,
            Duration expiry
    ) {
        return generateReadUrl(directory, fileName, expiry);
    }

    @Override
    public String upload(
            String directory,
            String fileName,
            byte[] content,
            String contentType,
            Map<String, String> metadata
    ) {
        try {
            String dir = normalizeDirectory(directory);
            String name = requireFileName(fileName);
            String objectPath = dir.isEmpty() ? name : dir + "/" + name;

            BlobInfo.Builder blobInfoBuilder = BlobInfo.newBuilder(bucket, objectPath)
                    .setContentType(contentType);

            if (metadata != null && !metadata.isEmpty()) {
                blobInfoBuilder.setMetadata(metadata);
            }

            storage.create(blobInfoBuilder.build(), content);

            return generateReadUrl(dir, name);
        } catch (Exception ex) {
            throw new com.intteq.storage.core.exception.StorageException(
                    "Failed to upload to Google Cloud Storage", ex
            );
        }
    }

    @Override
    public boolean exists(String directory, String fileName) {
        try {
            String dir = normalizeDirectory(directory);
            String name = requireFileName(fileName);
            String objectPath = dir.isEmpty() ? name : dir + "/" + name;

            return storage.get(bucket, objectPath) != null;
        } catch (Exception ex) {
            throw new com.intteq.storage.core.exception.StorageException(
                    "Failed to check object existence: " + fileName, ex
            );
        }
    }


    /**
     * Normalizes an expiry duration.
     *
     * <p>If the provided value is {@code null}, zero, or negative,
     * a safe fallback value is returned.
     *
     * @param expiry candidate expiry
     * @return a non-null, positive {@link Duration}
     */
    private static Duration normalizeExpiry(Duration expiry) {
        if (expiry == null || expiry.isZero() || expiry.isNegative()) {
            return FALLBACK_EXPIRY;
        }
        return expiry;
    }

    private static String normalizeDirectory(String directory) {
        if (directory == null || directory.trim().isEmpty()) {
            return "";
        }
        return directory.trim();
    }

    private static String requireFileName(String fileName) {
        if (fileName == null || fileName.trim().isEmpty()) {
            throw new IllegalArgumentException("fileName must not be null or empty");
        }
        return fileName.trim();
    }
}
